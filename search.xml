<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring学习</title>
      <link href="/2022/06/22/spring/"/>
      <url>/2022/06/22/spring/</url>
      
        <content type="html"><![CDATA[<h3 id="spring框架概述"><a href="#spring框架概述" class="headerlink" title="spring框架概述"></a>spring框架概述</h3><ul><li><p>spring是轻量级的开源javaee框架</p></li><li><p>spring可以解决企业应用开发的复杂性</p></li><li><p>spring有个核心的部分：IOC和AOP</p></li></ul><p> （1）IOC：控制反转，把创建对象的过程交给spring进行管理</p><p> （2）AOP：面向切面，不修改源代码的情况下进行功能增强</p><ul><li>spring的特点：</li></ul><p> （1）方便解耦，简化开发</p><p> （2）aop支持编程支持</p><p> （3）方便程序测试</p><p> （4）方便和其他框架进行整合</p><p> （5）方便进行事务操作</p><p> （6）降低api开发难度</p><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><p>（1）IOC底层原理</p><ul><li><p>概念：把对象创建和对象之间的调用过程交给spring进行管理，使用ioc是为了降低耦合度</p></li><li><p>原理：用到三个技术：xml解析、工厂模式、反射。[]</p></li></ul><p>（2）IOC接口（BeanFactory):</p><ul><li><p>1）IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p></li><li><p>2）spring提供IOC容器实现两种方式：</p><p>BeanFactory:IOC容器基本实现，是spring内部使用的接口，一般不提供开发人员进行使用，</p><p>注意：使用BeanFactory时，加载配置文件的时候不会创建对象，而是获取对象（使用）才去创建对象。</p><p>ApplicationContext:BeanFactory接口的子接口，提供更多强大的功能，一般由开发人员进行使用。</p><p>注意：使用ApplicationContext时，加载配置文件的时候会把在配置文件对象进行创建。</p></li></ul><p>（3）IOC操作bean管理（基于xml）</p><ul><li>基于xml方式创建对象：</li></ul><p> 1）在spring配置文件中，使用bean标签，标签里加对应的属性，就可以实现对象的创建</p><p> 2）id属性：唯一标识；class属性：类全路径（包类路径）</p><p> 3）创建对象时，默认执行无惨构造的方法完成对象的创建</p><ul><li>基于xml方式注入属性</li></ul><p> 1）DI：依赖注入，就是注入属性</p><p>第一种注入方式：使用set方法进行注入<br>1.创建类，定义属性和对应的set方法，在xml中创建对象的bean标签然后在bean标签内用property标签对属性赋值。</p><p>第二种注入方式：使用有参构造进行注入<br>1.创建类，定义属性和对应的有参构造，，在xml中创建对象的bean标签然后在bean标签内使用constructor-arg标签对属性赋值。</p><p>注意：在xml给属性设置null值时在bean标签的property内不用value属性而在内部加一个<null/>来对属性进行null值的设置；属性值包含特殊符号， 示例如下：(示例中的《xiaowu》就会原样输出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;property name &#x3D; &quot;xiaowu&quot;&gt;   &lt;value&gt;     &lt;![CDATA[&lt;&lt;xiaowu&gt;&gt;]]&gt;   &lt;&#x2F;value&gt;&lt;&#x2F;property&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>bean的作用域：如何设置单实例或多实例（scope：默认值（singleton 单实例） prototype 多实例）</p></li><li><p>bean生命周期：通过构造器创建bean实例（无参构造）—为bean的属性设置值和对其他bean的引用（通过set方法）—调用bean的初始化的方法（需要进行配置）—bean可以使用（对象获取到）—容器关闭，调用配置好的方法销毁bean</p></li></ul><p>（4）IOC操作bean管理（基于注解）</p><ul><li>注解是代码特殊标记，格式：@注解名称（属性名称&#x3D;属性值，属性名称&#x3D;属性值…）可以在类、属性、方法上使用注解；使用注解的是为了简化xml配置</li></ul><p>1.spring针对创建对象提供了以下几种注解：@Component、@Service、@Controller、@Repository，<br>  首先引入依赖，开启组件扫描，创建类并添加注解。</p><ul><li>开启组建扫描的方法：<br>1.在xml配置文件中通过声明一个context的名称空间，然后通过&lt;context：component-scan base-packag&#x3D;” 此次放需要扫描注解的包的上级目录”&gt;</context:component-scan>进行组建扫描；<br>2.创建一个配置类，以达到代替xml，配置类需要加上@Configuration 和@ComponentScan(base-package &#x3D; {“…”})</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">@Component(value &#x3D; &quot;service&quot;) &#x2F;&#x2F;value可以省略，一般不写就是类名首字母小写为value值public class Service &#123;     public void add()&#123;         System.out.println(&quot;service add.......&quot;);     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注解方式实现属性注入：<br>1. @AutoWired:根据属性类型进行自动注入<br>2. @Qualifier:根据属性名称进行注入，要和@AutoWired一起使用<br>3. @Resourse:可以根据类型注入也可以根据名称注入<br>4. @Value:注入普通类型属性</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><ul><li><p>概念：面向切面编程，利用aop可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率。在不修改源代码的情况下在主干功能里添加新功能。</p></li><li><p>aop底层使用动态代理<br>1.有接口情况：jdk动态代理，创建一个接口实现类的代理对象<br>2.没有接口情况：CGLIB动态代理，创建当前类子类的代理对象。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">@ jdk动态代理使用jdk动态代理，使用Proxy类里的方法创建代理对象，调用newProxyInstance方法newProxyInstance（ClassLoader loader,类&lt; ？&gt;[] interfaces,InvocationHandler h）返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。三个参数：第一个参数：类加载器第二个参数：增强方法所在类的实现的接口，支持多个接口第三个参数：实现这个接口InvocationHandler，创建代理对象写增强的方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>操作术语：<br>1.连接点：可以被增强的方法都是连接点<br>2.切入点：实际被增强的方法<br>3.通知（增强）：实际增强的逻辑部分就是通知；通知有以下几种：前置通知、后置通知、环绕通知、异常通知、最终通知<br>4.切面：是一个动作，把通知应用到切入点的过程。</p></li></ul><h3 id="jdbcTemplate"><a href="#jdbcTemplate" class="headerlink" title="jdbcTemplate"></a>jdbcTemplate</h3><ul><li>概念：spring对jdbc进行了封装，使用jdbcTemplate方便实现对数据库的操作。</li></ul><p>注意：实现批量增加用jdbcTemplate.batchUpdate（String sql,List&lt;object[]&gt; batchArgs)：<br>第一个参数：sql语句，第二个参数：List集合，添加多条记录数据，</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>1.事务的基本概念：是数据库操作的基本单元，是逻辑上的一组操作，要么都成功，一个失败所有都失败。</p><p>2.事务的四大特性(ACID)：<br>1.原子性：<br>2.一致性：<br>3.隔离性：<br>4.持久性：</p><p>3.事务添加到javaee的三层结构里的service层（业务逻辑层）</p><p>4.在spring中进行事务管理操作有编程式事务管理和声明式事务管理（使用）</p><h3 id="声明式事务管理（注解方式）"><a href="#声明式事务管理（注解方式）" class="headerlink" title="声明式事务管理（注解方式）"></a>声明式事务管理（注解方式）</h3><p>1在spring配置文件中配置事务管理器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;bean id &#x3D; &quot;transactionMananger&quot; class &#x3D; &quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;!--注入数据源--&gt;&lt;property name &#x3D; &quot;dataSource&quot; ref &#x3D; &quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.开启事务注解</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">在配置文件中引入tx名称空间&lt;tx:annotation-driven transaction-manager &#x3D; &quot;transactionManager&quot;&gt;&lt;&#x2F;tx:annotation-driven&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3.在service类（或service类里面的方法）上面添加事务注解</p><ul><li>@Transactional<br> 其参数配置：<br>1.propagation: 事务传播行为<br>2.ioslation: 事务的隔离级别(脏读、不可重复读、幻读）<br>1).脏读：一个未提交的事务读取到了另一个未提及事务的数据。<br>2).不可重复读：一个未提交的事务读取到了另一个提交事务修改的数据。 <br>3).幻读：一个未提交事务读取到另一个提交事务添加的数据。<br><br>隔离级别：<br>1).READ UNCOMMITTED(读未提交）: 三个都不能解决<br>2).READ COMMITTED(读已提交）: 能解决脏读 <br>3).REPEATABLE READ(可重复读）: 能解决脏读和不可重复读 <br> 4).SERIALIZABLE(可串行化）: 都能解决<br>注意： mysql默认的隔离级别为REPEATABLE READ(可重复读)<br><br>3.timeout: 超时时间;事务需要在一定时间内进行提交，如果未提交则会回滚。<br>4.readOnly: 是否只读；默认值false<br>5.rollbackFor: 回滚<br>6.norollbackFor: 不回滚</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web学习日记</title>
      <link href="/2022/06/22/web-xue-xi-ri-ji/"/>
      <url>/2022/06/22/web-xue-xi-ri-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="web学习日记"><a href="#web学习日记" class="headerlink" title="web学习日记"></a>web学习日记</h2><p><a href="https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/">笔记地址</a></p><h3 id="2022-6-20"><a href="#2022-6-20" class="headerlink" title="2022.6.20"></a>2022.6.20</h3><p>目前最常用的三种语言：<br>HTML: 解释型语言，超文本标记语言—决定页面上显示什么内容<br> CSS: 页面上的内容显示的风格（决定页面内容上的美观程度）<br>JavaScript：页面特效</p><ul><li>Html语法：</li></ul><ol><li><p><code>&lt;br/&gt;</code>  ：表示换行</p></li><li><p><code>&lt;p&gt;&lt;/p&gt;</code>：表示段落标签</p></li><li><p><code>&lt;img/&gt;</code>:图片标签，其中src为路径值，width为宽度，height为高度，alt为图片显示失败的提示信息</p></li><li><h1></h1> h1~h6;总共六级标题</li><li><p>列表标签:<br> <code>&lt;ol&gt;&lt;/ol&gt; </code>: 有序列表,标签内参数：start:表示从*开始,type显示的类型：A a I i 1(default) <br> <code>&lt;ul&gt;&lt;/ul&gt;</code> : 无序列表，type：disc（default),circle,square</p></li><li><p><code>&lt;b&gt;&lt;/b&gt;</code> : 加粗 <code>&lt;i&gt;&lt;/i&gt;</code> :斜体 <code>&lt;u&gt;&lt;/u&gt;</code>: 下划线</p></li><li><p>角标：下标 <code>&lt;sub&gt;&lt;/sub&gt;</code>  、 上标 <code>&lt;sup&gt;&lt;/sup&gt;</code></p></li><li><p>小于号：（&amp;lt；） 大于号：(&gt;) 小于等于：（&amp;le;) 大于等于：（&amp;ge；） 注册商标：（&amp;reg；） 版权符号（&amp;copy；）</p></li><li><p>span标签：不换行标记块</p></li><li><p>a标签表示超链接；href：链接的地址 <br> target：_self(在本窗口打开） _blank (在一个新窗口打开） _parent(在父窗口打开） _top(在顶层窗口打开）</p></li><li><p>表格标签：table: 行（tr） 列（td）表头（th）</p></li><li><p>表单标签 ： form；其中input标签中的name属性必须要定，否则文本框的数据不会发送给服务器；textarea表示的多行文本框不能随意换行，value值开始结束标签之间的内容。</p></li></ol><ul><li>css语法</li></ul><ol><li><p>css分类：标签样式表、类样式表、id样式表</p></li><li><p>css从位置上的分类：嵌入式样式表、内部样式表、外部样式表\</p></li><li><p>盒子模型：border 边框 ；margin 间距 ；padding 填充；</p></li></ol><h3 id="servlet（在容器中是单例、线程不安全）"><a href="#servlet（在容器中是单例、线程不安全）" class="headerlink" title="servlet（在容器中是单例、线程不安全）"></a>servlet（在容器中是单例、线程不安全）</h3><ol><li>servlet的继承关系：servlet接口下有一个GenericServlet抽象类Httpservlet</li></ol><ul><li>servlet中的核心方法：init(),service(),destroy()</li></ul><ol start="2"><li><p>servlet的生命周期：出生到死亡的过程对应servlet的三个方法：init(),service(),destroy()<br><br>默认情况下：第一次接受请求时，这个servlet会进行实例化、初始化、然后服务从第二次请求开始，每一次都是服务；当容器关闭时，其中所有的servlet实例都会被调用destroy方法进行销毁。</p></li><li><p>http协议（超文本传输协议）：</p></li></ol><p>(1) Http请求响应包含两个部分：请求和响应 </p><p> 1).请求包含三个部分：请求行、请求消息头、请求体</p><ul><li>请求行包括三个信息：请求的方式、请求的url、请求的协议<br> 请求消息头中包含了很多客户端想要告诉服务器的信息 <br> 请求体：有三种情况，1).get方式：没有请求体，但是有一个queryString；2).post方式，有请求体，form data 3). json格式，有请求体，request payload</li></ul><p> 2).响应包含响应行、响应头、响应体</p><ul><li>响应行包含了协议、状态码、响应状态 <br> 响应头包含了服务器的信息；服务器发送给浏览器的信息 <br> 响应体包含了响应的实际内容</li></ul><ol start="4"><li><p>服务器内部转发以及客户端重定向</p><p>(1)服务器内部转发：request.getRequestDispatcher(“ … “).forward(request,response);<br>(2)客户端重定向：response.sendRedirect(“….”);</p></li><li><p>Thymeleaf：</p></li></ol><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><ol><li>200：正常响应</li><li>404：找不到资源</li><li>405：请求方式不支持</li><li>500：服务器内部错误</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象（一）</title>
      <link href="/2022/06/13/mian-xiang-dui-xiang-yi/"/>
      <url>/2022/06/13/mian-xiang-dui-xiang-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="面向过程（pop）与面向对象（oop）"><a href="#面向过程（pop）与面向对象（oop）" class="headerlink" title="面向过程（pop）与面向对象（oop）"></a>面向过程（pop）与面向对象（oop）</h2><blockquote><p>二者都是一种思想，面向对象是相对于面向过程而言的。<br>  面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。<br>  面向对象，将功能封装进对象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。<br>  举例：人把大象装进冰箱<br>  1.面向过程：<br>  ① 把冰箱门打开<br>  ② 抬起大学塞进冰箱<br>  ③ 把冰箱门关闭<br>  2.面向对象：<br>  ①<br>  ②<br>  ③</p></blockquote><h2 id="java面向对象学习的三条主线"><a href="#java面向对象学习的三条主线" class="headerlink" title="java面向对象学习的三条主线"></a>java面向对象学习的三条主线</h2><ul><li>1.java的类及类的成员</li><li>2.面向对象的三大特征</li><li>3.其他关键字</li></ul><h3 id="java的类及类的成员"><a href="#java的类及类的成员" class="headerlink" title="java的类及类的成员"></a>java的类及类的成员</h3><blockquote><p>java的类及类的成员：属性、方法、构造器；代码块、内部类(前三个必须掌握牢固）</p></blockquote><ul><li>类(field)：是对一类事物的描述，是抽象的，概念上的定义</li><li>对象(method)：是实际存在的该类事物的每个个体。也称为实例(instance)。</li><li>面向对象程序设计的重点就是类的设计，设计类就是设计类的成员。</li><li>类和对象的使用(1.创建类，设计类的成员   2.创建类的对象    3.通过“对象.属性”或者“对象.方法”调用对象的结构)</li></ul><h4 id="常见的另类的成员有："><a href="#常见的另类的成员有：" class="headerlink" title="常见的另类的成员有："></a>常见的另类的成员有：</h4><ul><li>属性：对应类中的成员变量</li><li>行为：对应类中的成员方法</li></ul><h4 id="属性（成员变量）-vs-局部变量"><a href="#属性（成员变量）-vs-局部变量" class="headerlink" title="属性（成员变量） vs 局部变量"></a>属性（成员变量） vs 局部变量</h4><ul><li>相同点</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">定义变量的格式相同先声明，后使用变量都有其对应的作用域<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>不同点</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.在类中声明的位置不同：  属性（成员变量）：直接定义在类的一对&#123;&#125;内  局部变量:声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量2.权限修饰符的不同  属性：可以在声明属性时，指明其权限，使用权限修饰符        常见的权限修饰符：private、public、缺省、protected  局部变量：不可以使用权限修饰符3.默认初始化值的情况：  属性：类的属性，根据其类型，都有默认的初始化值        整型（byte、short、int、long） 0浮点型（float、double） 0.0字符型（char） 0（&#39;\u0000&#39;）布尔型（boolean） false引用数据类型（类、数组、接口） null    (注意：引用数据类型在内存中只可能存储 null 或 地址值）    局部变量：没有默认初始化值。            意味着，我们在调用局部变量之前，一定要显式赋值。特别的，形参在调用时赋值即可。4.在内存中加载的位置  属性：加载到堆空间中（非static）  局部变量：加载到栈空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>return关键字的使用<br>1.使用范围：使用在方法体中<br>2.作用：结束方法；<br>    针对有返回值类型的方法，使用’return 数据’方法返回所要的数据；<br>    注意点：return关键字后面不可以声明执行语句。</li></ul><h4 id="匿名对象的使用"><a href="#匿名对象的使用" class="headerlink" title="匿名对象的使用"></a>匿名对象的使用</h4><p>1.理解：我们创建的对象，没有显式的赋给一个变量名，即为匿名对象。</p><p>2.特征：匿名对象只能调用一次</p><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><ul><li><p>概念：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可。</p></li><li><p>特点：与返回值类型无关，只看参数列表，其参数列表必须不同（参数个数或者参数类型）。调用时根据方法参数列表的不同来区别。</p></li></ul><h4 id="可变个数的形参（jdk5-0新增内容）"><a href="#可变个数的形参（jdk5-0新增内容）" class="headerlink" title="可变个数的形参（jdk5.0新增内容）"></a>可变个数的形参（jdk5.0新增内容）</h4><ul><li><p>可变个数的形参：允许直接定义能和多个实参相匹配的形参。</p></li><li><p>当调用可变个数形参的方法时，传入的参数个数可以是0，1，2……</p></li><li><p>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。</p></li><li><p>可变个数形参的方法与本类中方法名相同，形参类型相同的数组之间不够成重载。</p></li><li><p>可变个数形参在方法的形参中，必须声明在末尾。</p></li><li><p>可变个数的形参在方法的形参中，最多只能声明一个可变个数形参。</p></li></ul><h4 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h4><ul><li><p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</p></li><li><p>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</p></li></ul><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><ul><li>概念：一个方法体内调用它自身。</li></ul><h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><blockquote><p>面向对象的三大特征：封装性、继承性、多态性、(抽象性）</p></blockquote><h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><ul><li><p>隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提高系统的可扩展性。</p></li><li><p>”高内聚、低耦合“：高内聚–类的内部数据操作细节自己完成，不允许外部干涉。低耦合–仅对外暴露少量的方法用于使用。</p></li></ul><h4 id="封装性的体现需要权限修饰赋来配合"><a href="#封装性的体现需要权限修饰赋来配合" class="headerlink" title="封装性的体现需要权限修饰赋来配合"></a>封装性的体现需要权限修饰赋来配合</h4><blockquote><p>java规定的4种权限（从小到大）：private、default（缺省）、protected、public<br>private：类内部<br>default：类内部；同一个包<br>protected：类内部；同一个包；不同包的子类<br>public：类内部；同一个包；不同包的子类；同一个工程</p></blockquote><ul><li>4种权限修饰赋可以用来修饰类及类的内部结构：属性、方法、构造器、内部类</li><li>修饰类只能使用default、public</li></ul><h3 id="构造器（构造方法-constructor）"><a href="#构造器（构造方法-constructor）" class="headerlink" title="构造器（构造方法 constructor）"></a>构造器（构造方法 constructor）</h3><p>构造器的作用：创建对象（A a &#x3D;new A() ，A()为构造器）</p><blockquote><p>注意：<br>1.如果没有显式的定义类的构造器的话，则系统会默认提供一个空参的构造器<br>2.定义构造器的格式：权限修饰符 类名（形参列表）{}</p></blockquote><h3 id="其他关键字"><a href="#其他关键字" class="headerlink" title="其他关键字"></a>其他关键字</h3><blockquote><p>其他关键字：this、super、static、final、abstract、interface、package、import等</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java基本语法（二）</title>
      <link href="/2022/06/04/java-ji-ben-yu-fa-er/"/>
      <url>/2022/06/04/java-ji-ben-yu-fa-er/</url>
      
        <content type="html"><![CDATA[<h2 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* 流程控制语句是用来控制程序中各语句执行顺序的语句。* 三种基本的流程结构：顺序结构、分支结构、循环结构。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* 程序从上至下逐行执行，中间没任何跳转和判断<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* 根据条件，选择性的执行某段代码，有if-else和switch-case两种分支语句<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="循环结构-1"><a href="#循环结构-1" class="headerlink" title="循环结构"></a>循环结构</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* 根据循环条件，重复性的执行某点代码，有while、do-while、for三种循环语句（foreach）；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="键盘输入（Scanner）"><a href="#键盘输入（Scanner）" class="headerlink" title="键盘输入（Scanner）"></a>键盘输入（Scanner）</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* 实现步骤：1.导包：import java.util.Scanner            2.Scanner的实例化：Scanner sc &#x3D; new Scanner(System.in) 3.调用Scanner类的相关方法来获取指定类型的变量           <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>数组是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名。通过编号的方式对这些数据进行统一管理。</li><li>数组名：</li><li>下标（索引）：</li><li>元素：</li><li>数组的长度：</li></ul><blockquote><p>数组的特点：1.有序排列<br>             2.数组属于引用数据类型，但数组元素可以是基本数据类型也可以是引用数据类型<br>             3.创建数组对象会在内存中开辟一整块连续的空间<br>             4.长度一旦确定就不能修改</p></blockquote><ul><li><p>一维数组元素默认初始化值：数组元素是整型：0</p></li><li><pre><code>                  数组元素是浮点型：0.0</code></pre><ul><li><pre><code>                    数组元素是char类型：0</code></pre><ul><li><pre><code>                    数组元素是boolean：false</code></pre></li></ul></li></ul></li><li><pre><code>                  数组元素是引用数据类型：null</code></pre></li><li><p>二维数组元素默认初始化值：外层数组元素为数组元素地址值，内层元素和一维一样</p></li><li><p>注意：声明为int[][] arr &#x3D; new int[4][]; 外层调用为null（因为每个位置对应的一维数组还未定义，一维数组属于引用类型</p></li><li><pre><code>                                    内层不允许调用会报空指针异常</code></pre></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* int[] arr &#x3D; &#123;1,2,3,4,5&#125;;   &#x2F;&#x2F;这种声明属于类型推断* int[] arr[] &#x3D; new int[3][3]; &#x2F;&#x2F;这是正确的，声明的为二维数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="常见的几种排序算法"><a href="#常见的几种排序算法" class="headerlink" title="常见的几种排序算法"></a>常见的几种排序算法</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java基本语法（一）</title>
      <link href="/2022/06/04/java-ji-ben-yu-fa-yi/"/>
      <url>/2022/06/04/java-ji-ben-yu-fa-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">定义：被java语言赋予了特殊含义，用做专门用途的字符串（单词）特点：关键词中所有的字母都为小写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">现java版本尚未使用但是存在，可能以后被作为关键字。goto、const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">定义：java对各种变量、方法和类等腰命名时使用的字符序列称为标识符技巧：凡是自己可以命名的地方都叫标识符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="定义合法标识符的规则"><a href="#定义合法标识符的规则" class="headerlink" title="定义合法标识符的规则"></a>定义合法标识符的规则</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.由26个英文字母大小写、0-9、_或$组成2.数字不可以开头3.不可以使用关键字和保留字，但能包含关键字和保留字4.java严格区分大小写，长度无限制5.标识符不能包含空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="java中的名称命名规范"><a href="#java中的名称命名规范" class="headerlink" title="java中的名称命名规范"></a>java中的名称命名规范</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.包名：多单词组成时所有字母都小写：xxxyyyzzz2.类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz3.变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写:xxxYyyZzz4.常量名：所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">变量的概念：1.内存中的一个存储区域2.该区域的数据可以在同一类型范围内不断变化3.变量是程序中最基本的存储单元。包含变量类型、变量名、和存储的值。变量的作用：1.用于在内存中保存数据使用变量时要注意：1.java中每个变量必须先声明在使用2.使用变量名来访问这个区域的数据3.变量的作用域：其定义所在的一对&#123;&#125;内4.变量只有在其作用域内才有效5.同一个作用域内，不能定义重名的变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h3><p>按数据类型分类</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">基本数据类型：数值型（整数类型（byte、short、int、long）、浮点类型（float、double））、字符型（char）、布尔型（boolean）引用数据类型：类（class）、接口（interface）、数组（[])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="强制类型转换和自动类型提升"><a href="#强制类型转换和自动类型提升" class="headerlink" title="强制类型转换和自动类型提升"></a>强制类型转换和自动类型提升</h2><h3 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">当容量小的数据类型的变量与容量大的数据类型进行运算，结果自动提升为容量大的数据类型byte 、char 、 short --&gt; int --&gt; long --&gt; float --&gt; double注意：byte、char、short三种类型的变量做运算时，结果为int型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">自动类型提升运算的逆运算例：double d1 &#x3D; 12.3；    int i1 &#x3D; （int）d1；注意：1.需要使用强转符；      2.强制类型转换可能会导致精度丢失；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串类型：String"><a href="#字符串类型：String" class="headerlink" title="字符串类型：String"></a>字符串类型：String</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">注意：string不属于基本数据类型，属于引用数据类型声明string类型需要用双引号string可以和8种基本数据类型变量做运算，且运算只能是连接运算：+运算结果仍为string类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* 所有数字在计算机底层都以二进制形式存在* 对于整数，有四种表示方式：      1.二进制：0-1；满2进1，以0b或0B开头  2.八进制：1-7；满8进1，以数字0开头表示  3.十进制：1-9；满10进1  4.十六进制：1-9及A-F；满16进1，以0x或0X开头表示（A-F不区分大小写）  原码 --&gt;(原码出符号位外，各个位取反）反码 --&gt;（反码+1） 补码注意：计算机底层都以补码的方式来存储数据！（十进制转化成二进制：除2取余的逆）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* 算术运算符：+ - * &#x2F; ++ -- * 赋值运算符: &#x3D;  (支持连续赋值）   扩展赋值运算符： +&#x3D; ， -+ ， *&#x3D; ， &#x2F;&#x3D; ， %&#x3D; * 比较运算符（关系运算符）：&#x3D;&#x3D; ， ！&#x3D; ， &lt; ， &gt; ， &lt;&#x3D;  ，&gt;&#x3D; ，* 逻辑运算符：&amp;（逻辑与）、|（逻辑或）、！（逻辑非）              &amp;&amp;（短路与）、||（短路或）、^（逻辑异或）* 位运算符：&lt;&lt; （左移）， &gt;&gt;（右移） ， &gt;&gt;&gt;（无符号右移） ，&amp;（与运算） ， |（或运算） ，^（异或运算） ，~（取反运算）* 三元运算符：（表达式1）？（表达式2）：（表达式3）；表达式1为true，结果为表达式2；否则结果为表达式3              注意：任意可以用三元运算符的都可以转化为if-else，反之，不成立。（两者都可以使用，优先选择三元运算符）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习博客的搭建</title>
      <link href="/2022/05/19/xue-xi-da-jian-bo-ke/"/>
      <url>/2022/05/19/xue-xi-da-jian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h3 id="下载git和nodejs"><a href="#下载git和nodejs" class="headerlink" title="下载git和nodejs"></a>下载git和nodejs</h3><p>nodejs下载完成之后需要进行环境变量的配置</p><h3 id="配置淘宝云"><a href="#配置淘宝云" class="headerlink" title="配置淘宝云"></a>配置淘宝云</h3><h3 id="简写指令"><a href="#简写指令" class="headerlink" title="简写指令"></a>简写指令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo n &quot;我的第一篇文章&quot;&#96; 等价于 &#96;hexo new &quot;我的第一篇文章&quot;&#96; 还等价于&#96;hexo new post &quot;我的第一篇文章&quot;&#96;&#96;hexo p&#96; 等价于 &#96;hexo publish&#96;&#96;hexo g&#96; 等价于 &#96;hexo generate&#96;&#96;hexo s&#96;等价于 &#96;hexo server&#96;&#96;hexo d&#96; 等价于 &#96;hexo deploy&#96; &#96;hexo deploy -g&#96; 等价于 &#96;hexo deploy --generate&#96; &#96;hexo generate -d&#96;等价于&#96;hexo generate --deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h3><p>hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p><p>hexo server -s #以静态模式启动</p><p>hexo server -p 5000 #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)</p><p>hexo server -i 192.168.1.1 #自定义 IP</p><p>hexo cean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</p><p>hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”&#x2F;blog&#x2F;source&#x2F;“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”&#x2F;blog&#x2F;public&#x2F; “ 路径下)</p><p>hexo d #将本地数据部署到远端服务器(如github)</p><p>hexo init 文件夹名称 #初始化XX文件夹名称</p><p>npm update hexo -g#升级</p><p>npm install hexo -g#安装</p><p>node-v #查看node.js版本号</p><p>npm -v #查看npm版本号</p><p>git –version #查看git版本号</p><p>hexo -v #查看hexo版本号</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new aaa &quot;bbb&quot;&#96; # 新建一篇文章,文章名称和标题分别为bbb.md 和 bbb. 文章采用aaa布局, 此时会在站点根目录下的----&gt;source-----&gt;_post文件夹下生成bbb.md文件, bbb.md文件的顶部(-----分割线上方区域,也称作Front matter区),生成&#96;layout : aaa&#96;&#96;title:&#96;&#96;date:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="学习Markdown"><a href="#学习Markdown" class="headerlink" title="学习Markdown"></a><a href="https://www.jianshu.com/p/7771794c88a1" title="Markdown的教程">学习Markdown</a></h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
